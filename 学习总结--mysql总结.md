# MySql

## 数据库系统概论

### 数据模型

- 层次模型(***层次数据库***：***IMS（Information Management System）数据库管理系统***)
- 网状模型(网状数据库：***IDMS***、***DMS1100***、***IMAGE***)
- 关系模型(关系型数据库：**MySql、Oracle、DB2、sql Server、sqllite**  )

### 数据库建模三大模式

- **模式**：概念模式是数据库中全体数据的逻辑结构和特征的描叙是所有用户数据的公共数据视图
- **外模式**：外模式的主要特点用来描述组成用户视图各个记录的组成、相互联系、数据的完整性和安全性、数据项的特征等
- **内模式**：内模式对应物理级数据库，内模式是所有模式中的最低层的表示

### 数据库建模三大结构

- 概念模型设计 , 逻辑模型设计 , 物理模型设计是数据库及数据仓库模型设计的三个主要步骤

- 概念结构（概念模型）：现实世界的抽象主要代表是E-R图
- 逻辑结构（逻辑模型）：数据存储的一种看法，不涉及具体的数据库(不一定是关系型数据库)
- 物理结构（物理模型）：针对数据库及表、字段以及关联的说明

### 数据库系统的组成

- 数据库：是指长期存储在计算机内的，有组织，可共享的数据的集合
- 软件：包括操作系统、数据库管理系统及应用程序
- 数据管理员：系统分析员和数据库设计人员、应用程序员、最终用户、数据库管理员

### 数据库系统事务和锁（不一定是关系型数据库）

- 数据库事务（**数据库恢复机制**）：数据库]事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。
- 数据库锁机制（**并发控制机制**）：封锁、二段锁协议
- 事务并发引起的问题：脏读、不可重复读、幻读
- 事务隔离级别：未提交读、已提交读、可重复读、可串行化

### 关系数据库标准语言SQL

- 数据定义语言DDL：数据定义语言DDL用来创建数据库中的各种对象-----表、视图、索引、同义词、聚簇等
- 数据查询语言DQL：基本结构是由SELECT子句，FROM子句，WHERE
- 数据操纵语言DML：INSERT、UPDATE、DELETE
- 数据控制语言DCL：数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制
- 事务处理语言TPL：TPL语句包括BEGIN TRANSACTION、COMMIT和ROLLBACK。
- 指针控制语言CCL：想DECLARE CURSOR、FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作

### 关系数据库表设计三大范式

- 第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。（**不可再分**）
- 第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。（**完全依赖**）
- 第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 （**直接依赖**）

### 关系型数据库触发器和存储过程

- 触发器：触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法
- 存储过程：存储过程（Stored Procedure）是在大型数据库系统中一组为了完成特定功能的SQL 语句集

## MySql 逻辑架构

- 连接层：对客户端的连接处理、安全认证、授权等
- 服务层：MySQL的核心服务功能层，包括查询解析、分析、查询缓存、内置函数、存储过程、触发器、视图等
- 引擎层：存储引擎，负责数据的存储和提取，MySQL服务器通过API与存储引擎通信，屏蔽了各种引擎之间的差异
- 存储层：数据存储层主要是将数据存储在运行与裸设备的文件系统之上,并完成与存储引擎的交互

## MySql service层

### 连接器

- 长连接
- 短连接
- 线程池

### 查询缓存

### 分析器

- 词法分析
- 语法分析

### 优化器

- 逻辑查询优化 ：生成逻辑查询执行计划

- 物理查询优化：生成物理查询执行计划

### 执行器

- 执行物理查询执行计划

## MySql 存储引擎

- **InnoDB(事务性)**
- **MyISAM(非事务性)**
- MeMory
- BDB
- MERGE
- EXAMPLE
- ARCHIVE
- CSV
- BLACKHOLE
- FEDERATED

## MySql InnoDB 索引

### 索引类型

#### 底层结构（索引方法）

- Hash索引（不支持范围查询,等值查询效率非常高）

- B+Tree

#### B+树叶子节点是否包含所有记录

- 聚簇索引与主键索引（唯一性、非空性、单一性）概念等价,每张表都有主键索引(row_id),即都有聚簇索引
- 非聚簇索引，又称辅助索引、二级索引、非主键索引

#### 包含字段个数

- 单值索引（可以是普通索引、唯一索引、主键索引）
- 复合索引（又称联合索引、组合索引），最左匹配，可以是联合主键索引、联合唯一索引、联合普通索引

#### 唯一性

- 唯一索引

#### 覆盖性

- 覆盖索引：如果索引中包含要查询字段,则该索引为覆盖索引，可以减少**回表**次数的非主键索引

#### 其他分类

- 普通索引
- 全文索引（可以使用ES）
- 前缀索引

#### 索引选择原则

- 为经常出现在关键字order by、group by、distinct后面的字段，建立索引。
-  在union等集合操作的结果集字段上，建立索引。其建立索引的目的同上。
- 为经常用作查询选择的字段，建立索引。
- 在经常用作表连接的属性上，建立索引。
- 考虑使用索引覆盖,减少回表

### 索引失效

- 如果条件中有or，即使其中有条件带索引也不会使用(这就是问什么尽量少使用or的原因)
- 对于多列索引，不是使用的第一部分，则不会使用索引
-  like查询是以%开头
-  如果列类型是字符串，那一定要在条件中使用引号引起来，否则不会使用索引
- 如果mysql估计使用全表扫秒比使用索引快，则不适用索引。

### 索引数据结构

- Hash索引
- B+树索引

### 索引应用场景

- 当数据多且字段值有相同的值得时候用普通索引
- 当字段多且字段值没有重复的时候用唯一索引
- 当有多个字段名都经常被查询的话用复合索引
- 不会出现在where条件中的字段不该建立索引
- 表增删改多而查询较少不要创建索引

### 索引下推（5.7后默认开启）

- **索引下推**（index condition pushdown ）简称ICP，在**Mysql5.6**的版本上推出，用于优化查询。
- 在不使用ICP的情况下，在使用**非主键索引（又叫普通索引或者二级索引）**进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。
- 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。
- **索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数**。

### explain调优优化

## MySql InnoDB 事务

### ACID

- 原子性（Atomicity）：原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。
- 一致性（Consistency）：一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
- 隔离性（Isolation）：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
- 持久性（Duration）：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

### 事务并发引起的问题

- 脏读（Dirty Read）:脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
- 不可重复读（Unrepeatable Read）:一个事务前后多次读取同一数据，但数据值不一致。（**数据被其他事务修改**）
- 幻读（Phantom Read）：一个事务前后多次读取同一数据，但数据值不一致。（**其他事务新增或者删除了数据**）
- 更新丢失

### 事务隔离级别

| \                | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| Read uncommitted | √    | √          | √    |
| Read committed   | ×    | √          | √    |
| Repeatable read  | ×    | ×          | √    |
| Serializable     | ×    | ×          | ×    |

- 未提交读：事务可以读取另一个未提交事务的数据
- 已提交读：事务要等另一个事务提交后才能读取数据
- 可重复读：事务结束前，不允许其他事务进行修改操作（不包括插入数据）
- 可串行化：事务串行化执行，但效率低下，比较消耗数据库性能

### Spring事务与数据库事务的关系

> 数据库事务和spring事务本质上其实是同一个概念,spring的事务是对数据库的事务的封装,最后本质的实现还是在数据库,假如数据库不支持事务的话,spring的事务是没有作用的.

### 事务隔离的两种方式

#### InnoDB 锁

##### 行锁模式

- **共享锁（S）**：允许事务去读一行，阻止其他事务对该数据进行修改
- **排它锁（X）**：允许事务去读取更新数据，阻止其他事务对数据进行查询或者修改
- **意向共享锁（IS）**：当一个事务要给一条数据加S锁的时候，会先对数据所在的表先加上IS锁，成功后才能加上S锁
- **意向排它锁(IX)**：当一个事务要给一条数据加X锁的时候，会先对数据所在的表先加上IX锁，成功后才能加上X锁

|      | X    | IX   | S    | IS   |
| ---- | ---- | ---- | ---- | ---- |
| X    | 冲突 | 冲突 | 冲突 | 冲突 |
| IX   | 冲突 | 兼容 | 冲突 | 兼容 |
| S    | 冲突 | 冲突 | 兼容 | 兼容 |
| IS   | 冲突 | 兼容 | 兼容 | 兼容 |

##### 加锁方式

- 意向锁是InnoDB自动加的，不需要用户干预
- 对于update、delete、insert语句,innodb会自动加上排它锁(X)
- 对于普通select语句,InnoDB不会加锁
- 事务可以显示的给记录集加共享锁和排他锁

##### 行锁实现方式

- record lock:对索引项加锁
- gap lock:对索引项之间的间隙、第一条记录前的间隙或最后一条记录的间隙加锁
- next-key locak:前两种的组合，对记录及其前面的间隙加锁
- InnoDB行锁的特点意味着，如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，和表锁一样!

#### MVCC（数据多版本并发控制）

##### 概念

> 通过一定机制生成一个数据请求时间点的一致性数据快照,并用这个快照来提供一定级别的一致性读取.从用户的角度来看,好像是数据库可以提供同一数据的多个版本,因此,这种技术叫做**数据多版本并发控制（MVCC）**

##### 基本原理

> MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

##### 基本特征

- 每行数据都存在一个版本，每次数据更新时都更新该版本。
- 修改时Copy出当前版本随意修改，各个事务之间无干扰。
- 保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）

#### 二段锁协议

#### 分布式事务下的二段提交和三段提交

## MySql 优化

- sql语句优化
- schema优化（优化数据库对象）
- 锁问题优化
- 优化mysql server
- 磁盘I/O问题
- 分区优化
- 应用优化

##  MySql 日志

- **redo log**(重做日志)
- **undo log**(回滚日志)
- **binlog**(二进制日志)
- errorlog(错误日志)
- **slow query log**(慢查询日志)
- general log(一般查询日志)
- relay log(中继日志)

## MySql buffer pool和change buffer

### buffer pool（缓冲池）

- 缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用
- 缓冲池(buffer pool)是一种常见的降低磁盘访问的机制
- 缓冲池通常以页(page)为单位缓存数据
- 缓冲池的常见管理算法是LRU，memcache，OS，InnoDB都使用了这种算法
- InnoDB对普通LRU进行了优化

### change buffer（写缓存）

- change buffer是InnoDB的写缓冲, 目的是降低写操作的磁盘IO
- 对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好
- 假设一个业务的更新模式是写入之后马上会做查询，不适合使用写缓存

## MySql 表空间结构（InnoDB）

### 表空间

- **段 （ segment ）**：也叫表；
- **区 （ extent ）**：物理上连续的几个页；
- **页 ( page ）**：16K

![](https://images2015.cnblogs.com/blog/524341/201604/524341-20160416104932379-1446683950.jpg)

### page页面存储格式

![](https://images2015.cnblogs.com/blog/524341/201604/524341-20160416104952770-1354249661.jpg)

- 页头（Page Header）：记录页面的控制信息，共占150字节，包括页的左右兄弟页面指针、页面空间使用情况等，页头的详细说明会在下一篇中描述。
-  最小虚记录、最大虚记录：两个固定位置存储的虚记录，本身并不存储数据。最小虚记录比任何记录都小，而最大虚记录比任何记录都大。
- 记录堆（record heap）：指上图的橙黄色部分。表示页面已分配的记录空间，也是索引数据的真正存储区域。记录堆分为两种，即有效记录和已删除记录。有效记录就是索引正常使用的记录，而已删除记录表示索引已经删除，不在使用的记录，如上图的深蓝色部分。随着记录的更新和删除越来越频繁，记录堆中已删除记录将会越多，即会出现越来越多的空洞（碎片）。这些已删除记录连接起来，就会成为页面的自由空间链表。
- 未分配空间：指页面未使用的存储空间，随着页面不断使用，未分配空间将会越来越小。当新插入一条记录时，首先尝试从自由空间链表中获得合适的存储位置（空间足够），如果没有满足的，就会在未分配空间中申请。
- slot区：slot是一些页面有效记录的指针，每个slot占两个字节，存储了记录相对页面首地址的偏移。如果页面有n条有效记录，那么slot的数量就在n/8+2~n/4+2之间。下一节详细介绍slot区，它是记录页面有序和二分查找的关键。
- 页尾（Page Tailer）：页面最后部分，占8个字节，主要存储页面的校验信息。

## MySql分区

### 概念

> MySQL在5.1时添加了对水平分区的支持。分区是将一个表或索引分解成多个更小，更可管理的部分。每个区都是独立的，可以独立处理，也可以作为一个更大对象的一部分进行处理。

###  分区类型

- RANGE分区
- LIST分区
- HASH分区
- KEY分区

### 分区优点

- 和单个磁盘或者文件系统分区相比，可以存储更多数据
- 优化查询，在where子句中包含分区条件时，可以只扫描必要的一个或多个分区来提高查询效率
- 对于已经过期或者不需要保存的数据，可以通过删除与这些数据有关的分区来快速删除数据
- 跨多个磁盘来分散数据查询，以获得更大的查询吞吐量

## MySql 分库分表和主从复制（架构篇）

## 深度分页优化方案

- 使用子查询优化
- 使用id限定优化
- 使用临时表优化
- 先对id进行分页,然后在根据id查询具体信息

##  实战

- debug pageHelper源码
- 慢查询日志使用
- explain查看执行计划
- 进行查询优化
- 进行分页优化

## count(*)、count(1)、count(列名)区别

- count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL,会自动优化到id
- count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL  
- count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）

