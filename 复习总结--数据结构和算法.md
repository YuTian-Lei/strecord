# 数据结构和算法

***
## 数据结构：
1. 线性表
	- 顺序表
	- 链表
2. 栈和队列
	- 优先级队列
	- 双端队列
3. 集合
	- 散列表
	- 跳表（Redis利用跳表实现有序集合Sorted Set）
4. 树
	- 二叉树
	- 线索二叉树
	- 树与森林
	- 树与森林的遍历
	- 堆
	- Huffman树
5. 图
	- 图的遍历
		- 深度优先
		- 广度优先
	- 最小生成树
		- Kruskal算法
		- Prim算法
	- 最短路径
6. 搜索结构
	- 二分查找
	- 二叉搜索树
    - 平衡二叉树（AVL树）
    - 红黑树
7.  索引结构
	   - B树
	   - B+树
*****
## 算法
1. 排序算法
	- 冒泡排序
	- 插入排序
	- 希尔排序
	- 快速排序
	- 选择排序
	- 归并排序
	- 基数排序
	- 堆排序
	- 桶排序
	- 大数据排序
2. 查找算法
	- 二分查找
	- 快排查找
3. 树的遍历
	- 二叉树的镜像遍历
	- 二叉树的前中后序、层次遍历
4. 最大子数组和算法
5. 最长公共子序算法
6. 最短路径算法
7. 最小生成树算法
8. 动态规划
9. 贪心算法
10. 分治算法
11. 回溯算法
12. KMP算法
13. LRU算法
14. Manacher算法
15. BEPRT算法
***
# 数据结构
### 1、AarryList、LinkedList、Stack、Queue常用方法
####1.1 AarryList用法
|ava.util.ArrayList < E > 的一些方法 | 描述
-|-
+add(o: E): void	| 在list的末尾添加一个元素o
+add(index: int, o: E): void|在指定的index处插入元素o
+set(index: int, o: E): E|设置指定index处的元素为o
+get(index: int): E|返回指定index处的元素
+clear(): void|从list中删除所有元素
+remove(o: Object): boolean|删除list中的第一个元素o，如果元素被删除，返回true
+remove(index: int): boolean|删除指定index处的元素，如果元素被删除，返回true
+size(): int|返回list中元素个数
+isEmpty(): boolean|如果list不含元素，返回true
+contains(o: Object): boolean|如果list含有元素o，返回true
+indexOf(o: Object): int|返回list中第一个匹配元素的index
+lastIndexOf(o: Object): int|返回list中最后一个匹配元素的index
### 1.2 LinkedList用法
**增加**：
add(E e)：在链表后添加一个元素；   通用方法
addFirst(E e)：在链表头部插入一个元素；  特有方法
addLast(E e)：在链表尾部添加一个元素；  特有方法
push(E e)：与addFirst方法一致  
offer(E e)：在链表尾部插入一个元素                                                                                                                                                  add(int index, E element)：在指定位置插入一个元素。      
offerFirst(E e)：JDK1.6版本之后，在头部添加； 特有方法                                                                                                         offerLast(E e)：JDK1.6版本之后，在尾部添加； 特有方法
**删除**：
remove() ：移除链表中第一个元素;    通用方法  
remove(E e)：移除指定元素；   通用方法
removeFirst(E e)：删除头，获取元素并删除；  特有方法
removeLast(E e)：删除尾；  特有方法
pollFirst()：删除头；  特有方法
pollLast()：删除尾；  特有方法
pop()：和removeFirst方法一致，删除头。 
poll()：查询并移除第一个元素     特有方法    
**查**：
get(int index)：按照下标获取元素；  通用方法
getFirst()：获取第一个元素；  特有方法
getLast()：获取最后一个元素； 特有方法
peek()：获取第一个元素，但是不移除；  特有方法
peekFirst()：获取第一个元素，但是不移除； 
peekLast()：获取最后一个元素，但是不移除；
pollFirst()：查询并删除头；  特有方法
pollLast()：删除尾；  特有方法
poll()：查询并移除第一个元素     特有方法
**其他：**
boolean contains(Object o)
size()
 void clear()
 int indexOf(Object o)
 int lastIndexOf(Object o)
### 1.3 Stack用法
Stack的一些方法|描述
-|-
push( num) | 入栈
pop()| 栈顶元素出栈
empty() |判定栈是否为空
peek() |获取栈顶元素
search(num) |判端元素num是否在栈中，如果在返回1，不在返回-1。
### 1.4 Queue用法
方法名   | 描述                   | 解释说明
-|-|-
add     | 增加一个元索           | 如果队列已满，则抛出一个IIIegaISlabEepeplian异常
remove  | 移除并返回队列头部的元素 | 如果队列为空，则抛出一个NoSuchElementException异常
element | 返回队列头部的元素      | 如果队列为空，则抛出一个NoSuchElementException异常
offer   | 添加一个元素并返回true  | 如果队列已满，则返回false
poll    | 移除并返问队列头部的元素 | 如果队列为空，则返回null
peek    | 返回队列头部的元素      | 如果队列为空，则返回null
put     | 添加一个元素           | 如果队列满，则阻塞
take    | 移除并返回队列头部的元素 | 如果队列为空，则阻塞
***
### 2、集合
#### 2.1 散列表
1. 散列方法
	- 除留余数法
	- 数字分析法
	- 平方取中法
	- 折叠法
2. 处理哈希冲突的方法
	- 开放定址法
		- 线性探测法
		- 二次探测法
		- 伪随机数探测法
	- 再哈希法
	- 链地址法
	- 建立一个公共溢出区
#### 2.2跳表
>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。
### 3、树
#### 3.1 线索二叉树
 >用自己的话说就是：原来我们求一棵二叉树的前序、中序、后序序列的时候，都必须用到递归遍历相应的二叉树，否则也得借助栈等结构来记录。这样的话，如果我们想很快的找到某一个节点在某种序列下的前驱或后继，每次都要遍历，这显然十分浪费时间。很自然，要是想避免这个重复工作，那么我们就需要把所有节点的前驱和后继记录下来，这样每次查找相应的记录就行了。于是就引出了——‘线索’一词。没错，真的是‘线索’，由线索找到相应节点的前驱和后继，很形象！ 
#### 3.2 线索二叉树相关知识点
- 线索二叉树前中后序线索化
- 线索二叉树的遍历
- 线索二叉树的插入和删除
#### 3.3 二叉树
**递归遍历**

	 * 中序遍历二叉树（递归）
	 */
	public void PrintBinaryTreeMidRecur(TreeNode<T> root)
	{
	    if (root!=null) 
	    {
	        PrintBinaryTreeMidRecur(root.left);
	        System.out.print(root.data);
	        PrintBinaryTreeMidRecur(root.right);
	    }
	}
**非递归遍历**

     * 中序遍历二叉树（非递归）
     * 
     * 思路：先将T入栈，遍历左子树；遍历完左子树返回时，栈顶元素应为T，
     *       出栈，访问T->data，再中序遍历T的右子树。  
     */
    public void PrintBinaryTreeMidUnrecur(TreeNode<T> root)
    {
        TreeNode<T> p=root;//p为当前节点
        LinkedList<TreeNode> stack=new LinkedList<>();
    
        //栈不为空时，或者p不为空时循环
        while(p!=null || !stack.isEmpty())
        {
            //当前节点不为空。压入栈中。并将当前节点赋值为左儿子
            if (p!=null) 
            {
                stack.push(p);
                p=p.left;
            }
            //当前节点为空：
            //  1、当p指向的左儿子时，此时栈顶元素必然是它的父节点
            //  2、当p指向的右儿子时，此时栈顶元素必然是它的爷爷节点
            //取出并访问栈顶元素，赋值为right
            else
            {
                p=stack.pop();
                System.out.print(p.data);
                p=p.right;
            }
        }
    }
**层次遍历**

	 * 层次遍历二叉树（非递归）   
	 */
	public void PrintBinaryTreeLayerUnrecur(TreeNode<T> root)
	{
	    LinkedList<TreeNode> queue=new LinkedList<>();
	    TreeNode<T> p;
	    queue.push(root);
	    while(!queue.isEmpty())
	    {
	        p=queue.removeFirst();
	        System.out.print(p.data);
	        if (p.left!=null)
	            queue.addLast(p.left);
	        if (p.right!=null)
	            queue.addLast(p.right);
	    }
	}
}
#### 3.4 哈夫曼树的应用
- 最优判定树
- Huffman编码
### 4、 图
#### 4.1图的存储
-	邻接表
-	邻接矩阵
#### 4.2 图的遍历
- 深度优先遍历
- 广度优先遍历
#### 4.3 最小生成树
- Kruskal算法
- Prime算法
#### 4.4 最短路径 
- Dijkstra算法   
### 5、二叉搜索树
-	AVL树
-	红黑树
>都是为提高搜索效率而建立的搜索结构
### 6、索引结构
>B树和B+树都是平衡多路搜索树

- B树
- B+树

>B+-tree：是应文件系统所需而产生的一种B-tree的变形树。
一棵m阶的B+树和m阶的B树的异同点在于：
1. 有n棵子树的结点中含有n-1 个关键字； (此处颇有争议，B+树到底是与B 树n棵子树有n-1个关键字 保持一致，还是不一致：B树n棵子树的结点中含有n个关键字，待后续查证。暂先提供两个参考链接：①wikipedia http://en.wikipedia.org/wiki/B%2B_tree#Overview；②http://hedengcheng.com/?p=525。而下面B+树的图尚未最终确定是否有问题，请读者注意)
2. 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)
3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)
![](http://hi.csdn.net/attachment/201106/7/8394323_1307440587b6WG.jpg)

# 算法
***
## 一、递归
### 思路步骤：
1. 分析问题，找出递归关系
2. 找出停止条件
3. 设计递归算法、确定参数，即构建递归体。
#### 经典题目
1. 斐波那契数列：

>经典数学问题之一；斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、……

>递归关系：
>
>f(0) = 1
>
>f(1) = 1
>
>f(n) = f(n-1)+f(n-2)

	public class Solution {
		public int Fibonacci(int n) {
	    	if(n==0)
	    	    return 0;
	    	if(n==1)
	    	     return 1;
	    	else
	    	    return Fibonacci(n-2)+Fibonacci(n-1);
		}
	}
2. 青蛙跳台阶
>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
>
>递归关系：
>
>f(1) = 1
>
>f(2) = 2
>
>f(n) = f(n-1)+f(n-2)
	public class Solution {
 	   public int JumpFloor(int target) {
 	       if(target == 1)
 	           return 1;
 	       if(target == 2)
 	           return 2;
 	       else
 	           return JumpFloor(target-1)+JumpFloor(target-2);
 	   }
	}

3. 变态跳台阶
>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

>递归关系：
>
>f(n)=f(n-1)+f(n-2)+...+f(1)
>
>f(n-1)=f(n-2)+f(n-3)+...+f(1)

>得出：
>
>f(1)=1
>
>f(n)=2*f(n-1) n>=2

	public class Solution {
		public int JumpFloorII(int target) {
		    if(target == 1)
		        return 1;
		    else
		        return 2*JumpFloorII(target-1);
		}
	}
***
## 动态规划
动态规划的核心思想：
>**动态规划其实质上是通过开辟记录表，记录已求解过的结果，当再次需要求解的时候，可以直接到那个记录表中去查找，从而避免重复计算子问题来达到降低时间复杂度的效果。算法的关键在于解决冗余，实际上是一个空间换时间的算法。**

动态规划的求解步骤：
1. 分析最优解的性质，并刻画其最优子结构特征；
2. 递归地定义最优值
3. 自底向上的方式计算出最优值，并记录相关信息
4. 根据计算最优值时得到的信息，构造最优解

动态规划的基本要素：
1. 最优子结构性质
2. **子问题重叠性质**
3. 自底向上的求解方法

总结：建立记录表，自下而上，递归关系式；

### 最大连续子数组和（动态规划）
递归关系式：
          |  0                        i=0
d[i] =  |  array[i]             d[i-1]<0   
          |  d[i-1]+array[i]   d[i-1]>0

	class Solution {
	public:
	int FindGreatestSumOfSubArray(vector<int> array) {
	    vector<int> dp(array.size(),0);//记录表
	    dp[0]=array[0];
	    int max_dp=INT_MIN;
	    for (int i = 1; i <= array.size()-1; ++i)
	    {
	        if(dp[i-1]<=0)     //判断上一个子问题的解是否小于0
	            dp[i]=array[i];
	        else
	            dp[i]=array[i]+dp[i-1];
	        if(dp[i]>max_dp)
	            max_dp=dp[i];
	    }
	    return max_dp;
	}
};

### 斐波那契数列

	import java.util.*;
	public class Solution {
	public int Fibonacci(int n) {
	       List<Integer> list = new ArrayList<Integer>();//记录表
	       return  Fibonacci(n,list);
	}
	public int Fibonacci(int n,List<Integer> list){
	    if(n == 0){
	       if(list.size()==n)
	            list.add(0);
	       return  0;
	    }
	    if(n == 1 ){
	      if(list.size()==n)
	            list.add(1);
	      return 1;
	    }
	    if(list.size()>=n){                           //记录添加条件
	        if(list.size()==n){
	           list.add(list.get(n-1)+list.get(n-2)); //将已经求得和记录进数组表中
	        }
	        return list.get(n); 
	    }
	    else 
	       return Fibonacci(n-1,list)+Fibonacci(n-2,list);
	}
}
### 最长公共子序列
	import java.lang.String;
	import java.util.Scanner;
	 
	public class Main {
	public static void main(String[] args) {
	    Scanner in = new Scanner(System.in);
	    while(in.hasNext()) {
	        String str1 = in.nextLine();
	        String str2 = in.nextLine();
	        System.out.println(new Main().maxSubSequence(str1,str2).length() > 0 ? new Main().maxSubSequence(str1,str2):-1);
	    }
	}
	  
	public  StringBuilder maxSubSequence(String str1,String str2) {
	    int M = str1.length();
	    int N = str2.length();
	    //多添加一行一列便于初始化
	    int[][] dp = new int[M+1][N+1];//dp[i][j] 表示 str1[0~i-1] 与 str2[0~j-1] 的最长公共子序列的长度
	    int[][] re = new int[M+1][N+1];
	           
	    StringBuilder maxSubSequence = new StringBuilder();
	    for(int i = 1;i < M+1;i++){
	        for(int j = 1;j < N+1;j++){
	            if(str1.charAt(i-1) == str2.charAt(j-1)){
	                dp[i][j] = dp[i-1][j-1] + 1;
	                re[i][j] = 1;
	            }else if(dp[i-1][j]>dp[i][j-1]){
	                dp[i][j] = dp[i-1][j];
	                re[i][j] = 2;
	            }else{
	                dp[i][j] = dp[i][j-1];
	                re[i][j] = 3;
	            }                   
	        }
	    }
	    lcs(M,N,str1,re,maxSubSequence);
	    return maxSubSequence;
	}
	public static void lcs(int i,int j,String str1,int[][] re,StringBuilder out){
	    if(i == 0||j == 0) return;
	    if(re[i][j] == 1){
	        lcs(i-1,j-1,str1,re,out);
	        out.append(str1.charAt(i-1));
	    }
	    else if(re[i][j] == 2){
	        lcs(i-1,j,str1,re,out);
	    }else
	        lcs(i,j-1,str1,re,out);
	}
}
***
## 分治法
>基本思想：
分治法的设计思想：将一个难以直接解决的规模较大的问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。例如大规模的数据排序...

>分治法所能解决的问题一般具有以下几个特征：
I. 该问题的规模缩小到一定的程度就可以容易地解决；
II. 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质
III. 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。
IV. 利用该问题分解出的子问题的解可以合并为该问题的解；

### 二分查找
### 快排
### 归并排序
***
## 贪心算法

**基本思想：**
>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止 。

**求解步骤：**
1. 建立数学模型来描述问题；
2. 把求解的问题分成若干个子问题；
3. 对每一子问题求解，得到子问题的局部最优解；
4. 把子问题的解局部最优解合成原来解问题的一个解。

**基本要素：**

1. 最优子结构
2. 贪心选择

**贪心算法与动态规划算法的主要区别:**
1. 贪心算法是自上而下的求解，从初始解出发，逐渐减小问题的规模；动态规划则是自下而上的求解
2. 动态规划有子问题重叠性质
3. 都有最优子结构性质

**总结：贪心算法，从初始解出发，根据贪心选择，每走一步，问题的规模就会减少。**

### 最大连续子数组和（贪心算法）

	public class Solution {
	    public int FindGreatestSumOfSubArray(int[] array) {
	        int largest=-1;
	        int sum=0;
	        for(int i=0;i<array.length;i++){
	            sum=sum+array[i];
	            if(sum>largest)
	                largest = sum;
	            if(sum<0)
	                sum=0;
	        }
	        return largest;
	    }
	}