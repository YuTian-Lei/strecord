# 设计模式

## 总纲
>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。

### 七大原则

- 开闭原则
- 里氏替换原则
- 依赖倒置原则
- 单一职责原则
- 接口隔离原则
- 迪米特法则
- 合成复用原则

### 设计模式的优点
- 做到低耦合，高内聚
- 针对适用的应用场景，提供解决方案

### 根据目的来分
- 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。
- 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。
- 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。

### 根据作用范围来分
- 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。
- 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。


![](https://img-blog.csdnimg.cn/20191217103257498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RLX2xUbGVp,size_16,color_FFFFFF,t_70)


###  GoF的23种设计模式的功能
1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
6. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
7. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
8. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
9. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
10. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
11. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
12. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
13. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
14. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
15. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
16. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
17. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
18. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
19. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
20. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
21. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
22. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
23. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

# 创建型模式

> 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。(**如何创建对象**)

## 单例模式

### 定义
>指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。

### 结构
- 单例类：包含一个实例且能自行创建这个实例的类。
- 访问类：使用单例的类。

![](http://c.biancheng.net/uploads/allimg/181113/3-1Q1131K441K2.gif)
### 优点和缺点
- 单例类只有一个实例对象；
- 该单例对象必须由单例类自行创建；
- 单例类对外提供一个访问该单例的全局访问点；

### 应用场景
- 在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
- 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。

## 原型模式（克隆）
### 定义
>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。

### 结构
- 抽象原型类：规定了具体原型对象必须实现的接口。
- 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。
- 访问类：使用具体原型类中的 clone() 方法来复制新的对象。

![](http://c.biancheng.net/uploads/allimg/181114/3-1Q114101Fa22.gif)
### 优点和缺点
- 对象之间相同或相似，即只是个别的几个属性不同的时候。
- 对象的创建过程比较麻烦，但复制比较简单的时候。


## 简单工厂、工厂方法、抽象工厂
- 简单工厂:一个工厂类，一个抽象产品；缺点：添加新功能时，违反开闭原则；
- 工厂方法：一个抽象工厂、一个抽象产品；一个工厂生产一种产品；遵循开闭原则；
- 抽象工厂：一个抽象工厂、多个抽象产品；一个工厂生产一系列产品簇；


## 简单工厂
### 定义
>简单工厂模式属于创建型模式又叫做静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

### 结构

![](https://img2018.cnblogs.com/blog/1539112/201904/1539112-20190403163237809-720247003.png)

### 简单实现
	public class ComputerFactory {
	public static Computer createComputer(String type){
	    Computer mComputer=null;
	    switch (type) {
	        case "lenovo":
	            mComputer=new LenovoComputer();
	           break;
	        case "hp":
	            mComputer=new HpComputer();
	            break;
	        case "asus":
	            mComputer=new AsusComputer();
	            break;
	
	    }
	    return mComputer;
	}
}

### 优点和缺点
#### 优点
- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

#### 缺点
- 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
- 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，同样破坏了“开闭原则”；在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构

### 应用场景
- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

## 工厂方法模式
### 定义
>工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。
### 结构
![](https://img-blog.csdn.net/20160828082911344)
### 优点和缺点
#### 优点
- 更符合开-闭原则
- 符合单一职责原则
- 不使用静态工厂方法，可以形成基于继承的等级结构
#### 缺点
- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
- 一个具体工厂只能创建一种具体产品

### 应用场景
- 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。
- 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
- 客户不关心创建产品的细节，只关心产品的品牌。

## 抽象工厂模式
### 定义
>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构

### 结构
![](http://c.biancheng.net/uploads/allimg/181114/3-1Q11416002NW.gif)

- 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
- 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
- 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
- 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。

### 简单实现
	//抽象工厂
	interface AbstractFactory{
		public Product1 newProduct1();
		public Product2 newProduct2();
	}
	
	//具体工厂
	class ConcreteFactory1 implements AbstractFactory
	{
		public Product1 newProduct1()
		{
	   	 System.out.println("具体工厂 1 生成-->具体产品 11...");
	  	  return new ConcreteProduct11();
		}
		public Product2 newProduct2()
		{
		    System.out.println("具体工厂 1 生成-->具体产品 21...");
		    return new ConcreteProduct21();
		}
	}

### 应用场景
- 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
- 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
- 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。

## 建造者模式
### 定义 
>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

### 结构

![](http://c.biancheng.net/uploads/allimg/181114/3-1Q1141H441X4.gif)

- 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件
- 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息
- 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法
- 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()

### 简单实现
	//客户类
	public class Client
	{
		public static void main(String[] args)
		{
	 	   Builder builder=new ConcreteBuilder();
		    Director director=new Director(builder);
	 	   Product product=director.construct();
	 	   product.show();
		}
	}

### 优点和缺点
#### 优点
- 各个具体的建造者相互独立，有利于系统的扩展
- 客户端不必知道产品内部组成的细节，便于控制细节风险

#### 缺点
- 产品的组成部分必须相同，这限制了其使用范围
- 如果产品的内部变化复杂，该模式会增加很多的建造者类

### 应用场景
- 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的
- 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的

# 结构性模式

> 结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。(**对象职责和特性**)

## 代理模式

### 定义
>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介

### 结构与实现
#### 结构
![](http://c.biancheng.net/uploads/allimg/181115/3-1Q115093011523.gif)

- 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
- 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
- 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

#### 实现(静态代理)
	//代理
	class Proxy 
	{
	    private Subject subject;
	    
	    public Proxy(Subject subject){
	    	this.subject = subject;
	    }
	    
	    public void Request()
	    {
	
	        preRequest();
	        subject.Request();
	        postRequest();
	    }
	    public void preRequest()
	    {
	        System.out.println("访问真实主题之前的预处理。");
	    }
	    public void postRequest()
	    {
	        System.out.println("访问真实主题之后的后续处理。");
	    }
	}
	
	//调用
	public static void main(String[] args) {
		Suject subject = new SubjectImpl();
		Proxy prox = new Proxy(subject);
		prox.Request();
		
	}

### 优点和缺点
#### 优点
- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
- 代理对象可以扩展目标对象的功能；
- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；
#### 缺点
- 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
- 增加了系统的复杂度；
### 应用场景
- 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
- 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
- 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
- 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
- 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。

## 适配器模式
### 定义
>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

### 模式的结构
- 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
- 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
- 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

### 类适配器模式结构图
![](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151045351c.gif)
### 类适配器模式代码实现

	//目标接口
	interface Target
	{
		public void request();
	}
	//适配者类
	class Adaptee
	{
		public void specificRequest()
		{       
		    System.out.println("适配者中的业务代码被调用！");
   	 	}
	}
	//类适配器类
	class ClassAdapter extends Adaptee implements Target
	{
    	public void request()
    	{
    	    specificRequest();
   	 	}
	}

### 对象适配器结构图
![](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151046105A.gif)
### 对象适配器代码实现

	package adapter;
	//对象适配器类
	class ObjectAdapter implements Target
	{
		private Adaptee adaptee;
		public ObjectAdapter(Adaptee adaptee)
		{
	 	   this.adaptee=adaptee;
		}
		public void request()
		{
	  		adaptee.specificRequest();
		}
	}
### 优缺点
#### 优点
- 客户端通过适配器可以透明地调用目标接口
- 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类
- 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题

### 缺点
- 对类适配器来说，更换适配器的实现过程比较复杂

### 应用场景
- 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致
- 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同

## 桥接模式

### 定义

> 桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
>
> 某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。

### 结构

- 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。（基础维度）
- 扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
- 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
- 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

![](http://c.biancheng.net/uploads/allimg/181115/3-1Q115125253H1.gif)

### 实现

```java
//简单来说就是以一个维度为基础类，其他维度拆分为抽象类或接口，通过具体的实现完成创建对象。将对象以组合的方式注入到基础类中，完成维度的拆分。（桥接模式）
package bridge;
public class BridgeTest
{
    public static void main(String[] args)
    {
        Implementor imple=new ConcreteImplementorA();
        Abstraction abs=new RefinedAbstraction(imple);
        abs.Operation();
    }
}
//实现化角色
interface Implementor
{
    public void OperationImpl();
}
//具体实现化角色
class ConcreteImplementorA implements Implementor
{
    public void OperationImpl()
    {
        System.out.println("具体实现化(Concrete Implementor)角色被访问" );
    }
}
//抽象化角色
abstract class Abstraction
{
   protected Implementor imple;
   protected Abstraction(Implementor imple)
   {
       this.imple=imple;
   }
   public abstract void Operation();   
}
//扩展抽象化角色
class RefinedAbstraction extends Abstraction
{
   protected RefinedAbstraction(Implementor imple)
   {
       super(imple);
   }
   public void Operation()
   {
       System.out.println("扩展抽象化(Refined Abstraction)角色被访问" );
       imple.OperationImpl();
   }
}
```

### 优点和缺点

#### 优点

- 可以创建与平台无关的类和程序
- 客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息
- 开闭原则：可以新增抽象部分和实现部分， 且它们之间不会相互影响
- 单一职责原则：抽象部分专注于处理高层逻辑， 实现部分处理平台细节

#### 缺点

- 对高内聚的类使用该模式可能会让代码更加复杂

### 应用场景

- 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时
- 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时
- 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时

## 装饰模式

### 定义

> 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式

### 结构

- 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象
- 具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责
- 抽象装饰（Decorator）角色：继承抽象构件并包含具体构件的实例，可以通过其子类扩展具体构件的功能
- 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任

![](http://c.biancheng.net/uploads/allimg/181115/3-1Q115142115M2.gif)

### 实现

```java
package decorator;
public class DecoratorPattern
{
    public static void main(String[] args)
    {
        Component p=new ConcreteComponent();
        p.operation();
        System.out.println("---------------------------------");
        Component d=new ConcreteDecorator(p);
        d.operation();
    }
}
//抽象构件角色
interface  Component
{
    public void operation();
}
//具体构件角色
class ConcreteComponent implements Component
{
    public ConcreteComponent()
    {
        System.out.println("创建具体构件角色");       
    }   
    public void operation()
    {
        System.out.println("调用具体构件角色的方法operation()");           
    }
}
//抽象装饰角色
class Decorator implements Component
{
    private Component component;   
    public Decorator(Component component)
    {
        this.component=component;
    }   
    public void operation()
    {
        component.operation();
    }
}
//具体装饰角色
class ConcreteDecorator extends Decorator
{
    public ConcreteDecorator(Component component)
    {
        super(component);
    }   
    public void operation()
    {
        super.operation();
        addedFunction();
    }
    public void addedFunction()
    {
        System.out.println("为具体构件角色增加额外的功能addedFunction()");           
    }
}
```



### 优点和缺点

#### 优点

- 采用装饰模式扩展对象的功能比采用继承方式更加灵活
- 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合

#### 缺点

- 装饰模式增加了许多子类，如果过度使用会使程序变得很复杂

### 应用场景

- 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时
- 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现
- 当对象的功能要求可以动态地添加，也可以再动态地撤销时
- **如果用继承来扩展对象行为的方案难以实现或者根本不可行****，** **你可以使用该模式**
- 许多编程语言使用 `final`最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。

## 外观模式

### 定义

> 是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

### 结构

- 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
- 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
- 客户（Client）角色：通过一个外观角色访问各个子系统的功能。

![](http://c.biancheng.net/uploads/allimg/181115/3-1Q115152143509.gif)

### 实现

```java
public class FacadePattern
{
    public static void main(String[] args)
    {
        Facade f=new Facade();
        f.method();
    }
}
//外观角色
class Facade
{
    private SubSystem01 obj1=new SubSystem01();
    private SubSystem02 obj2=new SubSystem02();
    private SubSystem03 obj3=new SubSystem03();
    public void method()
    {
        obj1.method1();
        obj2.method2();
        obj3.method3();
    }
}
//子系统角色
class SubSystem01
{
    public  void method1()
    {
        System.out.println("子系统01的method1()被调用！");
    }   
}
//子系统角色
class SubSystem02
{
    public  void method2()
    {
        System.out.println("子系统02的method2()被调用！");
    }   
}
//子系统角色
class SubSystem03
{
    public  void method3()
    {
        System.out.println("子系统03的method3()被调用！");
    }   
}
```

### 优点和缺点

### 优点

- 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
- 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
- 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。

### 缺点

- 不能很好地限制客户使用子系统类
- 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”

### 应用场景

- 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系
- 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问
- 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性

## 享元模式

### 定义

> 运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率

### 结构

- 抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入
- 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口
- 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以**参数的形式注入具体享元的相关方法中**
- 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象



![](http://c.biancheng.net/uploads/allimg/181115/3-1Q115161342242.gif)

### 实现

```java
package flyweight;
import java.util.HashMap;
public class FlyweightPattern
{
    public static void main(String[] args)
    {
        FlyweightFactory factory=new FlyweightFactory();
        Flyweight f01=factory.getFlyweight("a");
        Flyweight f02=factory.getFlyweight("a");
        Flyweight f03=factory.getFlyweight("a");
        Flyweight f11=factory.getFlyweight("b");
        Flyweight f12=factory.getFlyweight("b");       
        f01.operation(new UnsharedConcreteFlyweight("第1次调用a。"));       
        f02.operation(new UnsharedConcreteFlyweight("第2次调用a。"));       
        f03.operation(new UnsharedConcreteFlyweight("第3次调用a。"));       
        f11.operation(new UnsharedConcreteFlyweight("第1次调用b。"));       
        f12.operation(new UnsharedConcreteFlyweight("第2次调用b。"));
    }
}
//非享元角色
class UnsharedConcreteFlyweight
{
    private String info;
    UnsharedConcreteFlyweight(String info)
    {
        this.info=info;
    }
    public String getInfo()
    {
        return info;
    }
    public void setInfo(String info)
    {
        this.info=info;
    }
}
//抽象享元角色
interface Flyweight
{
    public void operation(UnsharedConcreteFlyweight state);
}
//具体享元角色
class ConcreteFlyweight implements Flyweight
{
    private String key;
    ConcreteFlyweight(String key)
    {
        this.key=key;
        System.out.println("具体享元"+key+"被创建！");
    }
    public void operation(UnsharedConcreteFlyweight outState)
    {
        System.out.print("具体享元"+key+"被调用，");
        System.out.println("非享元信息是:"+outState.getInfo());
    }
}
//享元工厂角色
class FlyweightFactory
{
    private HashMap<String, Flyweight> flyweights=new HashMap<String, Flyweight>();
    public Flyweight getFlyweight(String key)
    {
        Flyweight flyweight=(Flyweight)flyweights.get(key);
        if(flyweight!=null)
        {
            System.out.println("具体享元"+key+"已经存在，被成功获取！");
        }
        else
        {
            flyweight=new ConcreteFlyweight(key);
            flyweights.put(key, flyweight);
        }
        return flyweight;
    }
}
```

### 优点和缺点

#### 优点

- 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力

#### 缺点

- 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性
- 读取享元模式的外部状态会使得运行时间稍微变长

### 应用场景

- 系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。
- 大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。
- 由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。

## 组合模式

### 定义

> 有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性

### 结构

- 抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。

- 树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。

- 树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。

#### 透明方式

> 在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题

![](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151G62L17.gif)

#### 安全方式

> 在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性

![](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151GF5221.gif)

### 实现

![](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151GUH32.gif)

#### 透明方式

```JAVA
package composite;
import java.util.ArrayList;
public class CompositePattern
{
    public static void main(String[] args)
    {
        Component c0=new Composite(); 
        Component c1=new Composite(); 
        Component leaf1=new Leaf("1"); 
        Component leaf2=new Leaf("2"); 
        Component leaf3=new Leaf("3");          
        c0.add(leaf1); 
        c0.add(c1);
        c1.add(leaf2); 
        c1.add(leaf3);          
        c0.operation(); 
    }
}
//抽象构件
interface Component
{
    public void add(Component c);
    public void remove(Component c);
    public Component getChild(int i);
    public void operation();
}
//树叶构件
class Leaf implements Component
{
    private String name;
    public Leaf(String name)
    {
        this.name=name;
    }
    public void add(Component c){ }           
    public void remove(Component c){ }   
    public Component getChild(int i)
    {
        return null;
    }   
    public void operation()
    {
        System.out.println("树叶"+name+"：被访问！"); 
    }
}
//树枝构件
class Composite implements Component
{
    private ArrayList<Component> children=new ArrayList<Component>();   
    public void add(Component c)
    {
        children.add(c);
    }   
    public void remove(Component c)
    {
        children.remove(c);
    }   
    public Component getChild(int i)
    {
        return children.get(i);
    }   
    public void operation()
    {
        for(Object obj:children)
        {
            ((Component)obj).operation();
        }
    }    
}
```

#### 安全模式

```
package composite;
import java.util.ArrayList;
public class CompositePattern
{
    public static void main(String[] args)
    {
        Composite c0=new Composite(); 
        Composite c1=new Composite(); 
        Component leaf1=new Leaf("1"); 
        Component leaf2=new Leaf("2"); 
        Component leaf3=new Leaf("3");          
        c0.add(leaf1); 
        c0.add(c1);
        c1.add(leaf2); 
        c1.add(leaf3);          
        c0.operation(); 
    }
}
//抽象构件
interface Component
{
    public void operation();
}
//树叶构件
class Leaf implements Component
{
    private String name;
    public Leaf(String name)
    {
        this.name=name;
    }   
    public void operation()
    {
        System.out.println("树叶"+name+"：被访问！"); 
    }
}
//树枝构件
class Composite implements Component
{
    private ArrayList<Component> children=new ArrayList<Component>();   
    public void add(Component c)
    {
        children.add(c);
    }   
    public void remove(Component c)
    {
        children.remove(c);
    }   
    public Component getChild(int i)
    {
        return children.get(i);
    }   
    public void operation()
    {
        for(Component component:children)
        {
            component.operation();
        }
    }    
}
```



### 优点和缺点

#### 优点

- 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
- 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；

#### 缺点

- 设计较复杂，客户端需要花更多时间理清类之间的层次关系；
- 不容易限制容器中的构件；
- 不容易用继承的方法来增加构件的新功能；

### 应用场景

- 在需要表示一个对象整体与部分的层次结构的场合。
- 要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。

# 行为型模式

> 行为型模式用于描述程序在运行时复杂的流程控制，即描述**多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务**，它涉及**算法与对象间职责的分配**。行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。(**设计对象之间如何搭配合作完成复杂任务，同时包含设计如何创建对象和设计对象的职责和特性**)

## 模板方法模式
### 定义

>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种**类行为型模式**
### 特点

- 提高代码复用性，将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中
- 实现了反向控制，正确使用“钩子方法”可以使得子类控制父类的行为
### 模式的结构

- 抽象类：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。
	- 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法
	- 基本方法：是整个算法中的一个步骤，包含以下几种类型
		- 抽象方法：在抽象类中申明，由具体子类实现。
		- 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
		- 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种
- 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤
![](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xODExMTYvMy0xUTExNjA5NTQwNTMwOC5naWY)
![](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xODExMTYvMy0xUTExNjA5NTU1MDEyMy5naWY)
### 实现

```java
public class TemplateMethodPattern
{
    public static void main(String[] args)
    {
        AbstractClass tm=new ConcreteClass();
        tm.TemplateMethod();
    }
}
//抽象类
abstract class AbstractClass
{
    public void TemplateMethod() //模板方法
    {
        specificMethod();
        abstractMethod1();
        abstractMethod2();
    }  
    public void specificMethod() //具体方法
    {
        System.out.println("抽象类中的具体方法被调用...");
    }   
    public abstract void abstractMethod1(); //抽象方法1
    public abstract void abstractMethod2(); //抽象方法2
}
//具体子类
class ConcreteClass extends AbstractClass
{
    public void abstractMethod1()
    {
        System.out.println("抽象方法1的实现被调用...");
    }   
    public void abstractMethod2()
    {
        System.out.println("抽象方法2的实现被调用...");
    }
}
```

### 优点和缺点

#### 优点

- 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
- 它在父类中提取了公共的部分代码，便于代码复用。
- 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则
#### 缺点

- 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象
- 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度
### 应用场景

- 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
- 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。
- 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。

## 责任链模式

### 定义
>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。**责任链模式是一种对象行为型模式**

### 特点
>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。

### 模式的结构
- 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接
- 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
- 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

**结构图如图 1 所示。客户端可按图 2 所示设置责任链：**
![](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xODExMTYvMy0xUTExNjEzNVoxMUMuZ2lm)

#### 实现

```Java
public class ChainOfResponsibilityPattern
{
    public static void main(String[] args)
    {
        //组装责任链 
        Handler handler1=new ConcreteHandler1(); 
        Handler handler2=new ConcreteHandler2(); 
        handler1.setNext(handler2); 
        //提交请求 
        handler1.handleRequest("two");
    }
}
//抽象处理者角色
abstract class Handler
{
    private Handler next;
    public void setNext(Handler next)
    {
        this.next=next; 
    }
    public Handler getNext()
    { 
        return next; 
    }   
    //处理请求的方法
    public abstract void handleRequest(String request);       
}
//具体处理者角色1
class ConcreteHandler1 extends Handler
{
    public void handleRequest(String request)
    {
        if(request.equals("one")) 
        {
            System.out.println("具体处理者1负责处理该请求！");       
        }
        else
        {
            if(getNext()!=null) 
            {
                getNext().handleRequest(request);             
            }
            else
            {
                System.out.println("没有人处理该请求！");
            }
        } 
    } 
}
//具体处理者角色2
class ConcreteHandler2 extends Handler
{
    public void handleRequest(String request)
    {
        if(request.equals("two")) 
        {
            System.out.println("具体处理者2负责处理该请求！");       
        }
        else
        {
            if(getNext()!=null) 
            {
                getNext().handleRequest(request);             
            }
            else
            {
                System.out.println("没有人处理该请求！");
            }
        } 
    }
}
```

### 优点和缺点

#### 优点
- 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息
- 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则
- 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任
- 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句
- 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则
#### 缺点
- 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理
- 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响
- 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用

### 应用场景
- 有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定
- 可动态指定一组对象处理请求，或添加新的处理者
- 在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求

### 实际使用中的示例
- tomcat容器中Request请求在Engine、Host、Context、Wrapper等容器的处理过程
- filter过滤器

## 观察者模式

### 定义
>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是**对象行为型模式**。

### 模式的结构
- 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法
- 具体主题（Concrete    Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象
- 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用
- 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态

 ![](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xODExMTYvMy0xUTExNjFBNjIyMVMuZ2lm)
### 实现

```Java
public class ObserverPattern
{
    public static void main(String[] args)
    {
        Subject subject=new ConcreteSubject();
        Observer obs1=new ConcreteObserver1();
        Observer obs2=new ConcreteObserver2();
        subject.add(obs1);
        subject.add(obs2);
        subject.notifyObserver();
    }
}
//抽象目标
abstract class Subject
{
    protected List<Observer> observers=new ArrayList<Observer>();   
    //增加观察者方法
    public void add(Observer observer)
    {
        observers.add(observer);
    }    
    //删除观察者方法
    public void remove(Observer observer)
    {
        observers.remove(observer);
    }   
    //通知观察者方法
    public abstract void notifyObserver(); 
}
//具体目标
class ConcreteSubject extends Subject
{
    public void notifyObserver()
    {
        System.out.println("具体目标发生改变...");
        System.out.println("--------------");       
       
        for(Observer obs:observers)
        {
            obs.response();
        }
       
    }          
}
//抽象观察者
interface Observer
{
    void response(); //反应
}
//具体观察者1
class ConcreteObserver1 implements Observer
{
    public void response()
    {
        System.out.println("具体观察者1作出反应！");
    }
}
//具体观察者1
class ConcreteObserver2 implements Observer
{
    public void response()
    {
        System.out.println("具体观察者2作出反应！");
    }
}
```

### 优点和缺点

#### 优点
- 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系
- 目标与观察者之间建立了一套触发机制
#### 缺点
- 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用
- 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率

### 事件委托

#### 定义

>抽象通知者还是依赖了抽象观察者,当没有抽象观察者时,使用事件委托的方法。（解决的问题就是，当各个观察者更新方法名字不同时，使用事件委托）

#### 特点

- 没有具体的观察者抽象接口
- 在目标类中创建一个事件委托对象EventHandler
- 在使用时将观察者要更新的方法通过反射委托给EventHandler
- 当目标类改变时，遍历List<Event>,通知观察者

#### 实现

```Java
public class ObserverPattern
{
    public static void main(String[] args)
    {
        Subject subject=new ConcreteSubject();
        Observer obs1=new ConcreteObserver1();
        Observer obs2=new ConcreteObserver2();
        //添加事件
        subject.addEvent(obs1,"run");
        subject.addEvent(obs2,"sleep",1000);
        subject.notifyObserver();
    }
}


//事件类
public class Event {
	private Object target;
 
	private String methodName;
 
	private Object[] params;
 
	private Class[] paramsTypes;
 
	public Event(Object target, String methodName, Object[] params) {
		this.target = target;
		this.methodName = methodName;
		this.params = params;
		createParamsTypes(params);
	}
	/**
	 * 获取参数类型，反射时用
	 */
	private void createParamsTypes(Object[] params) {
		paramsTypes = new Class[params.length];
		for (int i = 0; i < params.length; i++) {
			paramsTypes[i] = params[i].getClass();
		}
	}
 
	/**
	 * invoke方法,调用目标类方法
	 */
	public void invoke() {
		try {
			Method method = target.getClass().getMethod(methodName, paramsTypes);
			method.invoke(target, params);
		} catch (Exception e) {
			log.error("委托执行异常",e);
		}
	}
}

//抽象目标类
public abstract class Subject {
	protected List<Event> eventList = new ArrayList<>();
 	//添加委托事件
	public void addEvent(Event event) {
		eventList.add(event);
	}
 
	/**
	 * 添加委托事件
	 */
	public void addEvent(Object object, String methodName, Object... args) {
		Event event = new Event(object, methodName, args);
        eventList.add(event);
	}
 
	/**
	 * 通知观察者方法
	 */
	public abstract void notifyObserver();
}
//具体目标类
class ConcreteSubject extends Subject
{
    public void notifyObserver()
    {
        System.out.println("具体目标发生改变...");
        System.out.println("--------------");       
       
      	for (Event e : eventList) {
			e.invoke();
		}
    }          
}

//具体观察者1
class ConcreteObserver1 
{
    public void run()
    {
        System.out.println("具体观察者1作出反应！");
    }
}
//具体观察者1
class ConcreteObserver2 
{
    public void sleep(long time)
    {
        System.out.println("具体观察者2作出反应,睡了" + time +"秒");
    }
}

```



### 监听器模式

#### 定义

> 监听器，字面上的理解就是监听观察某个事件（程序）的发生情况，当被监听的事件真的发生了的时候，事件发生者（事件源） 就会给注册该事件的监听者（监听器）发送消息，告诉监听者某些信息，同时监听者也可以获得一份事件对象，根据这个对象可以获得相关属性和执行相关操作。

####  结构

- 事件对象：用户对**组件的一个操作**，或者说程序执行某个方法，称之为一个事件，如机器人程序执行工作。
- 事件源：**发生事件的组件就是事件源**，也就是被监听的对象，如机器人可以工作，可以跳舞，那么就可以把机器人看做是一个事件源
- 监听器：监听并负责处理事件的方法，如监听机器人工作情况，在机器人工作前后做出相应的动作，或者获取机器人的状态信息。
#### 原理
>事件源经过事件的封装传给监听器，当事件源触发事件后，监听器接收到事件对象可以回调事件的方法。

![在这里插入图片描述](C:\Users\lenovo\Desktop\学习总结\img\format.png)

![](C:\Users\lenovo\Desktop\学习总结\img\1118635-20180821160439733-1857455760.png)

#### 执行顺序

- 给事件源注册监听器
- 组件接受外部作用,也就是事件被触发
- 组件产生一个相应的事件对象,并把此对象传递给与之关联的事件处理器
- 事件处理器启动,并执行相关的代码来处理该事件

#### 实现

```Java
//事件对象
public class DataSource{
    public void open(){
        log.info("打开数据库");
    }
    
    public void close(){
        log.info("关闭数据库");
    }
}
//事件源
public class SourceEvent{
    private Listener listener;
    
    private DataSource  dataSource;
    
    public SourceEvent(DataSource dataSource){
        this.dataSource = dataSource;
    }	
    //注册监听器
    public void registeListener(Listener listener){
       this.listener  = listener;
    }
    //发生事件
    public void openDataSource(){
        //将事件对象传递给监听器,由监听器处理事件对象
        listener.open(dataSource);
    }
    //发生事件    
    public void closeDataSource(){
        //将事件对象传递给监听器,由监听器处理事件对象
        listener.close(dataSource);
    } 
}

public interface Listener{
   void open(DataSource dataSource);
   void close(DataSource dataSource);
}

public class DataSourceListener implements Listener{
    public void open(DataSource dataSource){
        //todo 打开数据库连接之前做一些操作
        dataSource.open();
        //todo 打开数据库连接之后做一些操作
    }
    
    public void close(DataSource dataSource){
        //todo 关闭数据库连接之前做一些操作
        dataSource.close();
        //todo 关闭数据库连接之后做一些操作
    }
}

public class Solution{
    public static void main(String[] args){
        //事件对象
        DataSource dataSource = new DataSource();
        //事件源
        SourceEvent sourceEvent = new SourceEvent(dataSource);
        //监听器
        Listener listener = new DataSourceListener();
        
        //事件源注册监听器
        sourceEvent.registeListener(listener);
        //事件触发
        SourceEvent.openDataSource();
        SourceEvent.closeDataSource();
    }
}
```

## 策略模式

### 定义

> 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。**策略模式属于对象行为模式**，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理

### 结构

- 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现
- 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现
- 环境（Context）类：持有一个策略类的引用，最终给客户端调用

![](C:\Users\lenovo\Desktop\学习总结\img\3-1Q116103K1205.png)

### 实现

```Java
public class StrategyPattern
{
    public static void main(String[] args)
    {
        Context c=new Context("A");
        
        if("A".equals(c.getStrategyName())){
            Strategy s=new ConcreteStrategyA();
            c.setStrategy(s);
            c.process();
        }else if("B".equals(c.getStrategyName())){
            Strategy s=new ConcreteStrategyB();
            c.setStrategy(s);
            c.process();
        } 
    }
}
//抽象策略类
interface Strategy
{   
    //策略方法
    public void strategyMethod();   
}
//具体策略类A
class ConcreteStrategyA implements Strategy
{
    public void strategyMethod()
    {
        System.out.println("具体策略A的策略方法被访问！");
    }
}
//具体策略类B
class ConcreteStrategyB implements Strategy
{
  public void strategyMethod()
  {
      System.out.println("具体策略B的策略方法被访问！");
  }
}
//环境类
class Context
{
    private String strategyName;
    private Strategy strategy;
    
    public Context(String strategyName){
        this.strategyName = strategyName;
    }
    
    public String getStrategyName()
    {
        return strategyName;
    }
    
    public void setStrategy(Strategy strategy)
    {
        this.strategy=strategy;
    }
    public void process()
    {
        strategy.strategyMethod();
    }
}
```

### 优点和缺点

#### 优点

- **多重条件语句不易维护**，而使用策略模式可以避免使用多重条件语句
- 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码
- 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的
- 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法
- 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离

#### 缺点

- 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类
- 策略模式造成很多的策略类

### 应用场景

- 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中
- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句
- 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时
- 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构
- 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为

## 命令模式

### 定义

> 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理

### 结构

- 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。
- 具体命令角色（Concrete  Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
- 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。
- 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。

![](C:\Users\lenovo\Desktop\学习总结\img\3-1Q11611335E44.png)

### 实现

```Java
//迪米特法则完美运用
public class CommandPattern
{
    public static void main(String[] args)
    {	
        //发送者
        Sender sender = new Sender();
        //命令对象
        Command command = new ConcreteCommand();
        //接收者
        Receiver receiver = new Receiver();
        
        sender.setCommand(command);
        command.setReceiver(receiver);
        
        System.out.println("客户访问调用者的call()方法...");
        sender.call();
    }
}
//调用者
class Sender
{
    private Command command;

    public void setCommand(Command command)
    {
        this.command=command;
    }
    
    public void call()
    {
        System.out.println("调用者执行命令command...");
        command.execute();
    }
}
//抽象命令
interface Command
{
     void execute();
     void setReceiver(Receiver receiver);
}
//具体命令
class ConcreteCommand implements Command
{
    private Receiver receiver;
    
    public void setReceiver(Receiver receiver)
    {
        this.receiver=receiver;
    }
    
    public void execute()
    {
        receiver.action();
    }
}
//接收者
class Receiver
{
    public void action()
    {
        System.out.println("接收者的action()方法被调用...");
    }
}
```

### 优点和缺点

#### 优点

- 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
- 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
- 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
- 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。

#### 缺点

- 可能产生大量具体命令类。因为需要对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。

### 应用场景

- 当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。
- 当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。
- 当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。
- 当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。

### 扩展使用(宏命令模式)

```Java
//命令模式与组合模式搭配使用
public class CompositeCommandPattern
{
    public static void main(String[] args)
    {
        //发送者
        Sender sender = new Sender();
        //构建宏命令对象
        Command root = new ConcreteCommands();
        
        Command branch = new ConcreteCommands();
        Command leaf1 = new ConcreteCommand1();
        Command leaf2 = new ConcreteCommand2();
        
        Command leaf3 = new ConcreteCommand1();
        Command leaf4 = new ConcreteCommand2();
        
        root.add(branch);
        root.add(leaf1);
        root.add(leaf2);
        
        branch.add(leaf3);
        branch.add(leaf4);
        
        //接收者
        Receiver receiver = new Receiver();
       
        sender.setCommand(root);
        root.setReceiver(receiver);
        
        System.out.println("客户访问调用者的call()方法...");
        sender.call();
    }
}

//调用者
class Sender
{
    private Command command;

    public void setCommand(Command command)
    {
        this.command=command;
    }
    
    public void call()
    {
        System.out.println("调用者执行命令command...");
        command.execute();
    }
}


//抽象命令
interface Command
{
    void execute();
    void setReceiver(Receiver receiver);
}
//树叶构件: 具体命令1
class ConcreteCommand1 implements Command
{
    private Receiver receiver;
    
    public void setReceiver(Receiver receiver)
    {
        this.receiver=receiver;
    }
    
    public void execute()
    {       
        receiver.action1();
    }
}
//树叶构件: 具体命令2
class ConcreteCommand2 implements Command
{
    private Receiver receiver;
    public void setReceiver(Receiver receiver)
    {
        this.receiver=receiver;
    }
    public void execute()
    {       
        receiver.action2();
    }
}
//树枝构件: 命令组
class ConcreteCommands implements Command
{
    private ArrayList<Command> children = new ArrayList<Command>();  
    
    public void setReceiver(Receiver receiver){
        for(Command obj:children){
            obj.setReceiver(receiver);
        }
    }
    
    public void add(Command c)
    {
        children.add(c);
    }   
    public void remove(Command c)
    {
        children.remove(c);
    }   

    public void execute()
    {
        for(Object obj:children)
        {
            ((Command)obj).execute();
        }
    }    
}
//接收者
class Receiver
{
    public void action1()
    {
        System.out.println("接收者的action1()方法被调用...");
    }
    public void action2()
    {
        System.out.println("接收者的action2()方法被调用...");
    }
}
```

## 状态模式

### 定义

> 对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为;状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变(**环境类包含状态类对象,不同状态设置不同的状态对象，将不同状态下的行为实现放到状态类中**)

### 结构

- 环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
- 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
- 具体状态（Concrete  State）角色：实现抽象状态所对应的行为

![](C:\Users\lenovo\Desktop\学习总结\img\3-1Q11615412U55.gif)

### 实现

```Java
public class StatePatternClient
{
    public static void main(String[] args)
    {       
        Context context=new Context();    //创建环境       
        context.Handle();    //处理请求
        context.Handle();
        context.Handle();
        context.Handle();
    }
}
//环境类
class Context
{
    private State state;
    //定义环境类的初始状态
    public Context()
    {
        this.state=new ConcreteStateA();
    }
    //设置新状态
    public void setState(State state)
    {
        this.state=state;
    }
    //读取状态
    public State getState()
    {
        return(state);
    }
    //对请求做处理
    public void Handle()
    {
        state.Handle(this);
    }
}
//抽象状态类
abstract class State
{
    public abstract void Handle(Context context);
}
//具体状态A类
class ConcreteStateA extends State
{
    public void Handle(Context context)
    {
        System.out.println("当前状态是 A.");
        context.setState(new ConcreteStateB());
    }
}
//具体状态B类
class ConcreteStateB extends State
{
    public void Handle(Context context)
    {
        System.out.println("当前状态是 B.");
        context.setState(new ConcreteStateA());
    }
}
```

### 优点和缺点

#### 优点

- 状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”
- 减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖
- 有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换

#### 缺点

- 状态模式的使用必然会增加系统的类与对象的个数
- 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。

### 应用场景

- 状态模式的使用必然会增加系统的类与对象的个数
- 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱

### 扩展使用

```Java
//可能有多个环境对象需要共享一组状态，这时需要引入享元模式，将这些具体状态对象放在集合中供程序共享
//此组合模式使用并不合理
public class FlyweightStatePattern
{
    public static void main(String[] args)
    {
        ShareContext context1=new ShareContext(); //创建环境  
        ShareContext context2=new ShareContext(); //创建环境 
        context1.Handle(); //处理请求
        context1.Handle();
        context2.Handle();
        context2.Handle();
    }
}
//环境类(非享元对象)
class ShareContext
{
    private ShareState state;
    //享元工厂
    private HashMap<String, ShareState> stateSet=new HashMap<String, ShareState>();
    public ShareContext()
    {
        state=new ConcreteState1();
        stateSet.put("1", state);
        state=new ConcreteState2();
        stateSet.put("2", state);
        state=getState("1");
    }
    //设置新状态
    public void setState(ShareState state)
    {	
        this.state=state;
    }
    //读取状态
    public ShareState getState(String key)
    {
        ShareState s=(ShareState)stateSet.get(key);
        return s;
    }
    //对请求做处理
    public void Handle()
    {	//将非享元对象以参数形式注入具体享元的相关方法
        state.Handle(this);
    }
}
//抽象状态类(抽象享元角色)
abstract class ShareState
{
    public abstract void Handle(ShareContext context);
}
//具体状态1类(具体享元角色1)
class ConcreteState1 extends ShareState
{
    public void Handle(ShareContext context)
    {
        System.out.println("当前状态是： 状态1");
        context.setState(context.getState("2"));
    }
}
//具体状态2类(具体享元角色2)
class ConcreteState2 extends ShareState
{
    public void Handle(ShareContext context)
    {
        System.out.println("当前状态是： 状态2");
        context.setState(context.getState("1"));
    }
}
```

## 中介者模式

### 定义

> 定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是**迪米特法则的典型应用**

### 结构

- 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法
- 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色
- 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能
- 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互

![](C:\Users\lenovo\Desktop\学习总结\img\3-1Q1161I532V0.png)

### 实现

```Java
//Eureka就是使用中介者模式,将各个服务注册到Eureka服务器,各个服务之间的调用通过Eureka获取调用地址
public class MediatorPattern
{
    public static void main(String[] args)
    {
        Mediator mediator = new ConcreteMediator();
        Colleague  colleague1 = new ConcreteColleague1("colleague1");
        Colleague  colleague2 = new ConcreteColleague2("colleague2");
        
        mediator.register(c1);
        mediator.register(c2);
        
        colleague1.send("colleague2");
        colleague2.send("colleague1");
    }
}
//抽象中介者
abstract class Mediator
{
    protected Map<String,Colleague> colleagues = new HashMap<String,Colleague>();
    public abstract void register(Colleague colleague);
    public abstract void relay(String name); //转发
}
//具体中介者
class ConcreteMediator extends Mediator
{
    public void register(Colleague colleague)
    {
        if(!colleagues.containsKey(colleague.getName()))
        {
            colleagues.set(colleague.getName(),colleague);
            colleague.setMedium(this);
        }
    }
    
    public void relay(String name)
    {
        Colleague colleague = colleagues.get(name);
        if(null != colleague){
            colleague.receive();
        }
    }
}
//抽象同事类
abstract class Colleague
{
    private String name;
    protected Mediator mediator;
    
    public Colleague(String name){
        this.name = name;
    }
    
    public void setMedium(Mediator mediator)
    {
        this.mediator=mediator;
    }   
    
    public void setName(String name){
        this.name = name;
    }
    
    public String getName(){
        return name;
    }
    
    public void send(String name)
    {
        System.out.println("具体同事"+ this.name +"发出请求。");
        mediator.relay(name); //请中介者转发
    }
    
    public abstract void receive();   

}
//具体同事类
class ConcreteColleague1 extends Colleague
{
    public ConcreteColleague1(String name){
        super(name);
    }
    
    public void receive()
    {
        System.out.println("具体同事类1收到请求。");
    }   
}
//具体同事类
class ConcreteColleague2 extends Colleague
{
    public ConcreteColleague2(String name){
        super(name);
    }
    
    public void receive()
    {
        System.out.println("具体同事类2收到请求。");
    }   
}
```

### 优点和缺点

#### 优点

- 降低了对象之间的耦合性，使得对象易于独立地被复用
- 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展

#### 缺点

- 当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护

### 应用场景

- 当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。
- 当想创建一个运行于多个类之间的对象，又不想生成新的子类时

### 扩展使用

```Java
//不定义中介者接口，把具体中介者对象实现成为单例。
//同事对象不持有中介者，而是在需要的时f矣直接获取中介者对象并调用
public class SimpleMediatorPattern
{
    public static void main(String[] args)
    {
        SimpleColleague c1,c2;
        c1=new SimpleConcreteColleague1();
        c2=new SimpleConcreteColleague2();
        c1.send();
        System.out.println("-----------------");
        c2.send();
    }
}
//简单单例中介者
class SimpleMediator
{
    private static SimpleMediator smd=new SimpleMediator();   
    private List<SimpleColleague> colleagues=new ArrayList<SimpleColleague>();   
    private SimpleMediator(){}   
    public static SimpleMediator getMedium()
    {    return(smd);   }
    public void register(SimpleColleague colleague)
    {
        if(!colleagues.contains(colleague))
        {
            colleagues.add(colleague);
        }
    }
    public void relay(SimpleColleague scl)
    {       
        for(SimpleColleague ob:colleagues)
        {
            if(!ob.equals(scl))
            {
                ((SimpleColleague)ob).receive();
            }   
        }
    }
}
//抽象同事类
interface SimpleColleague
{
    void receive();   
    void send();
}
//具体同事类
class SimpleConcreteColleague1 implements SimpleColleague
{
    SimpleConcreteColleague1(){
        SimpleMediator smd=SimpleMediator.getMedium();
        smd.register(this);
    }
    public void receive()
    {    System.out.println("具体同事类1：收到请求。");    }   
    public void send()
    {
        SimpleMediator smd=SimpleMediator.getMedium();
        System.out.println("具体同事类1：发出请求...");
        smd.relay(this); //请中介者转发
    }
}
//具体同事类
class SimpleConcreteColleague2 implements SimpleColleague
{
    SimpleConcreteColleague2(){
        SimpleMediator smd=SimpleMediator.getMedium();
        smd.register(this);
    }
    public void receive()
    {    System.out.println("具体同事类2：收到请求。");    }   
    public void send()
    {
        SimpleMediator smd=SimpleMediator.getMedium();
        System.out.println("具体同事类2：发出请求...");
        smd.relay(this); //请中介者转发
    }
}
```

## 迭代器模式

### 定义

> 提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下

### 结构

- 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
- 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
- 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
- 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

![](C:\Users\lenovo\Desktop\学习总结\img\3-1Q1161PU9528.png)

### 实现

```Java
public class IteratorPattern
{
    public static void main(String[] args)
    {
        Aggregate ag=new ConcreteAggregate(); 
        ag.add("中山大学"); 
        ag.add("华南理工"); 
        ag.add("韶关学院");
        System.out.print("聚合的内容有：");
        Iterator it=ag.getIterator(); 
        while(it.hasNext())
        { 
            Object ob=it.next(); 
            System.out.print(ob.toString()+"\t"); 
        }
        Object ob=it.first();
        System.out.println("\nFirst："+ob.toString());
    }
}
//抽象聚合
interface Aggregate
{ 
    public void add(Object obj); 
    public void remove(Object obj); 
    public Iterator getIterator(); 
}
//具体聚合
class ConcreteAggregate implements Aggregate
{ 
    private List<Object> list=new ArrayList<Object>(); 
    public void add(Object obj)
    { 
        list.add(obj); 
    }
    public void remove(Object obj)
    { 
        list.remove(obj); 
    }
    public Iterator getIterator()
    { 
        return(new ConcreteIterator(list)); 
    }     
}
//抽象迭代器
interface Iterator
{
    Object first();
    Object next();
    boolean hasNext();
}
//具体迭代器
class ConcreteIterator implements Iterator
{ 
    private List<Object> list=null; 
    private int index=-1; 
    public ConcreteIterator(List<Object> list)
    { 
        this.list=list; 
    } 
    public boolean hasNext()
    { 
        if(index<list.size()-1)
        { 
            return true;
        }
        else
        {
            return false;
        }
    }
    public Object first()
    {
        index=0;
        Object obj=list.get(index);;
        return obj;
    }
    public Object next()
    { 
        Object obj=null; 
        if(this.hasNext())
        { 
            obj=list.get(++index); 
        } 
        return obj; 
    }   
}
```

### 优点和缺点

#### 优点

- 访问一个聚合对象的内容而无须暴露它的内部表示
- 遍历任务交由迭代器完成，这简化了聚合类
- 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历
- 增加新的聚合类和迭代器类都很方便，无须修改原有代码
- 封装性良好，为遍历不同的聚合结构提供一个统一的接口

#### 缺点

- 增加了类的个数，这在一定程度上增加了系统的复杂性

### 应用场景

- 当需要为聚合对象提供多种遍历方式时
- 当需要为遍历不同的聚合结构提供一个统一的接口时
- 当访问一个聚合对象的内容而无须暴露其内部细节的表示时

## 备忘录模式

### 定义

> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式

### 结构

- 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
- 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
- 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。

![](C:\Users\lenovo\Desktop\学习总结\img\3-1Q119130413927.png)

### 实现

```Java
public class MementoPattern
{
    public static void main(String[] args)
    {
        Originator or=new Originator();
        Caretaker cr=new Caretaker();       
        or.setState("S0"); 
        System.out.println("初始状态:"+or.getState());           
        cr.setMemento(or.createMemento()); //保存状态      
        or.setState("S1"); 
        System.out.println("新的状态:"+or.getState());        
        or.restoreMemento(cr.getMemento()); //恢复状态
        System.out.println("恢复状态:"+or.getState());
    }
}
//备忘录
class Memento
{ 
    private String state; 
    public Memento(String state)
    { 
        this.state=state; 
    }     
    public void setState(String state)
    { 
        this.state=state; 
    }
    public String getState()
    { 
        return state; 
    }
}
//发起人
class Originator
{ 
    private String state;     
    public void setState(String state)
    { 
        this.state=state; 
    }
    public String getState()
    { 
        return state; 
    }
    public Memento createMemento()
    { 
        return new Memento(state); 
    } 
    public void restoreMemento(Memento m)
    { 
        this.setState(m.getState()); 
    } 
}
//管理者
class Caretaker
{ 
    private Memento memento;       
    public void setMemento(Memento m)
    { 
        memento=m; 
    }
    public Memento getMemento()
    { 
        return memento; 
    }
}
```

### 优点和缺点

#### 优点

- 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态
- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息
- 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则

#### 缺点

- 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源

### 应用场景

- 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能
- 需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作

## 访问者模式

### 定义

> 将作用于**某种数据结构中的各元素的操作分离出来封装成独立的类**，使其在**不改变数据结构的前提下可以添加作用于这些元素的新的操作**，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为型模式中最复杂的一种模式（访问者（Visitor）模式是一种**对象行为型模式**）

### 结构

- 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
- 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
- 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
- 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
- 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。

![](C:\Users\lenovo\Desktop\学习总结\img\3-1Q11910135Y25.png)

### 实现

```Java
//不同的访问者对同一个对象有不同的访问方法
public class VisitorPattern
{
    public static void main(String[] args)
    {
        ObjectStructure os=new ObjectStructure();
        os.add(new ConcreteElementA());
        os.add(new ConcreteElementB());
        Visitor visitor=new ConcreteVisitorA();
        //访问者A访问对象结构
        os.accept(visitor);
        System.out.println("------------------------");
        visitor=new ConcreteVisitorB();
        //访问者B访问对象结构
        os.accept(visitor);
    }
}
//抽象访问者
interface Visitor
{
    void visit(Element element);

}
//具体访问者A类
class ConcreteVisitorA implements Visitor
{
    public void visit(Element element)
    {
        //todo 访问者A具体的访问方法
        System.out.println("具体访问者A访问-->"+element.operation());
        //todo 访问者A具体的访问方法
    }
}
//具体访问者B类
class ConcreteVisitorB implements Visitor
{
    public void visit(Element element)
    {
        //todo 访问者B具体的访问方法
        System.out.println("具体访问者B访问-->"+element.operation());
        //todo 访问者B具体的访问方法
    }
}
//抽象元素类
interface Element
{
    void accept(Visitor visitor);
    String operation();
}
//具体元素A类
class ConcreteElementA implements Element
{
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }
    public String operation()
    {
        return "具体元素A的操作。";
    }
}
//具体元素B类
class ConcreteElementB implements Element
{
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }
    public String operation()
    {
        return "具体元素B的操作。";
    }
}
//对象结构角色
class ObjectStructure
{   
    private List<Element> list=new ArrayList<Element>();   
    public void accept(Visitor visitor)
    {
        Iterator<Element> i=list.iterator();
        while(i.hasNext())
        {
            ((Element) i.next()).accept(visitor);
        }      
    }
    public void add(Element element)
    {
        list.add(element);
    }
    public void remove(Element element)
    {
        list.remove(element);
    }
}
```

### 优点和缺点

#### 优点

- 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
- 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
- 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
- 符合单一职责原则。访问者模式把相关的行为封装在一起,构成一个访问者,使每一个访问者的功能都比较单一

#### 缺点

- 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
- 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
- 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。

### 应用场景

- 对象结构相对稳定，但其操作算法经常变化的程序。
- 对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。
- 对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。